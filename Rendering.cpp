
/** $VER: Rendering.cpp (2025.09.14) P. Stuer **/

#include "pch.h"
#include "UIElement.h"

#include "Direct2D.h"
#include "DirectWrite.h"
#include "WIC.h"

#include "Resources.h"
#include "Color.h"
#include "Gradients.h"
#include "StyleManager.h"

#include "ToneGenerator.h"
#include "Log.h"

#pragma hdrstop

/// <summary>
/// Starts the timer.
/// </summary>
void UIElement::StartTimer() noexcept
{
    if (_ThreadPoolTimer != nullptr)
        StopTimer();

    _ThreadPoolTimer = ::CreateThreadpoolTimer(TimerCallback, this, nullptr);

    FILETIME DueTime = { };

    ::SetThreadpoolTimer(_ThreadPoolTimer, &DueTime, 1000 / (DWORD) _MainState._RefreshRateLimit, 0);
}

/// <summary>
/// Stops the timer.
/// </summary>
void UIElement::StopTimer() noexcept
{
    if (_ThreadPoolTimer == nullptr)
        return;

    ::SetThreadpoolTimer(_ThreadPoolTimer, nullptr, 0, 0);

    ::WaitForThreadpoolTimerCallbacks(_ThreadPoolTimer, true);

    ::CloseThreadpoolTimer(_ThreadPoolTimer);
    _ThreadPoolTimer = nullptr;
}

/// <summary>
/// Handles a timer tick.
/// </summary>
void CALLBACK UIElement::TimerCallback(PTP_CALLBACK_INSTANCE instance, PVOID context, PTP_TIMER timer) noexcept
{
    ((UIElement *) context)->OnTimer();
}

/// <summary>
/// Handles a timer tick.
/// </summary>
void UIElement::OnTimer()
{
    if (_IsFrozen || !_IsVisible || ::IsIconic(core_api::get_main_window()))
        return;

    LONG64 BarrierState = ::InterlockedIncrement64(&_ThreadState._Barrier);

    if (BarrierState != 1)
    {
        ::InterlockedDecrement64(&_ThreadState._Barrier);

        return;
    }

    bool HaveColorsChanged = false;

    if (_CriticalSection.TryEnter())
    {
        ProcessEvents();

        if (IsWindowVisible())
            Render();

        if (_IsConfigurationChanged)
        {
        //  Log::Write(Log::Level::Trace, "%8d: Sending colors changed message.", (uint32_t) ::GetTickCount64());

            _MainState._ArtworkGradientStops = _ThreadState._ArtworkGradientStops;

            _IsConfigurationChanged = false;

            HaveColorsChanged = true;
        }

        _CriticalSection.Leave();
    }

    // Notify the configuration dialog about the changed artwork colors.
    if (HaveColorsChanged && _ConfigurationDialog.IsWindow())
    {
        _ConfigurationDialog.PostMessageW(UM_CONFIGURATION_CHANGED, CC_COLORS); // Must be sent outside the critical section.

        HaveColorsChanged = false;
    }

    ::InterlockedDecrement64(&_ThreadState._Barrier);
}

/// <summary>
/// Allows the rendering thread to react to events captured in or generated by the UI thread.
/// </summary>
void UIElement::ProcessEvents()
{
    Event::Flags Flags = _Event.GetFlags();

    if (Flags == 0)
        return;

    if (Event::IsRaised(Flags, Event::PlaybackStopped))
    {
    //  Log::Write(Log::Level::Trace, "%8d: Playback stopped.", (uint32_t) ::GetTickCount64());

        _ThreadState._PlaybackTime = 0.;
        _ThreadState._TrackTime = 0.;

        for (auto & Iter : _Grid)
            Iter._Graph->Reset();

        _Artwork.Release();
    }

    if (Event::IsRaised(Flags, Event::PlaybackStartedNewTrack))
    {
    //  Log::Write(Log::Level::Trace, "%8d: Started new track.", (uint32_t) ::GetTickCount64());

        _ThreadState._PlaybackTime = 0.;
        _ThreadState._TrackTime = 0.;

        if (_Artwork.Bitmap() == nullptr)
        {
            // Set the default dominant color and gradient for the artwork color scheme.
            _ThreadState._ArtworkGradientStops = GetGradientStops(ColorScheme::Artwork);
            _ThreadState._StyleManager._DominantColor = _ThreadState._ArtworkGradientStops[0].color;

            _ThreadState._StyleManager.SetArtworkDependentParameters(_ThreadState._ArtworkGradientStops, _ThreadState._StyleManager._DominantColor);

            _IsConfigurationChanged = true;
        }

        for (auto & Iter : _Grid)
            Iter._Graph->Reset();
    }

    if (Event::IsRaised(Flags, Event::UserInterfaceColorsChanged))
    {
        _ThreadState._StyleManager.UpdateCurrentColors();
        _ThreadState._StyleManager.ReleaseDeviceSpecificResources();
    }
}

/// <summary>
/// Renders a frame.
/// </summary>
void UIElement::Render()
{
    HRESULT hr = CreateDeviceSpecificResources();

    if (SUCCEEDED(hr) && !(_RenderTarget->CheckWindowState() & D2D1_WINDOW_STATE_OCCLUDED))
    {
        _FrameCounter.NewFrame();

        Process();

        _RenderTarget->BeginDraw();

        for (auto & Iter : _Grid)
            Iter._Graph->Render(_RenderTarget, _Artwork);

        if (_MainState._ShowFrameCounter)
            _FrameCounter.Render(_RenderTarget);

        hr = _RenderTarget->EndDraw();

        if (hr == D2DERR_RECREATE_TARGET)
        {
            ReleaseDeviceSpecificResources();

            hr = S_OK;
        }

        Animate();
    }
}

/// <summary>
/// Updates the spectrum of all the graphs using the next audio chunk.
/// </summary>
void UIElement::Process() noexcept
{
    if (!_VisualisationStream.is_valid())
        return;

    double PlaybackTime; // in seconds

    if (!_VisualisationStream->get_absolute_time(PlaybackTime))
        return;

    if (PlaybackTime == _ThreadState._PlaybackTime)
        return; // Playback is paused.

    audio_chunk_impl Chunk;

    if ((_ThreadState._SampleRate == 0) && _VisualisationStream->get_chunk_absolute(Chunk, PlaybackTime, 0.001))
        InitializeSampleRateDependentParameters(Chunk);

    if (_ThreadState._SampleRate == 0)
        return;

    if (_ThreadState._UseToneGenerator)
    {
        if (_ToneGenerator.GetChunk(Chunk, _ThreadState._SampleRate))
        {
            for (auto & Iter : _Grid)
                Iter._Graph->Process(Chunk);
        }
    }
    else
    {
        const bool IsSlidingWindow = (_ThreadState._Transform == Transform::SWIFT) || (_ThreadState._Transform == Transform::AnalogStyle);

        const double WindowSize = IsSlidingWindow ? PlaybackTime - _ThreadState._PlaybackTime : (double) _ThreadState._BinCount / (double) _ThreadState._SampleRate;
        const double Offset     = IsSlidingWindow ?                _ThreadState._PlaybackTime : PlaybackTime - (WindowSize * (0.5 + _ThreadState._ReactionAlignment));

        if (_VisualisationStream->get_chunk_absolute(Chunk, Offset, WindowSize))
        {
            for (auto & Iter : _Grid)
                Iter._Graph->Process(Chunk);
        }

        _ThreadState._PlaybackTime = PlaybackTime;
    }
}

/// <summary>
/// Initializes the parameters that depend on the sample rate of the chunk.
/// </summary>
void UIElement::InitializeSampleRateDependentParameters(audio_chunk_impl & chunk) noexcept
{
    _ThreadState._SampleRate = chunk.get_sample_rate();

    #pragma warning (disable: 4061)
    switch (_ThreadState._FFTMode)
    {
        default:
            _ThreadState._BinCount = (size_t) (64. * ::exp2((long) _ThreadState._FFTMode));
            break;

        case FFTMode::FFTCustom:
            _ThreadState._BinCount = (_ThreadState._FFTCustom > 0) ? (size_t) _ThreadState._FFTCustom : 64;
            break;

        case FFTMode::FFTDuration:
            _ThreadState._BinCount = (_ThreadState._FFTDuration > 0.) ? (size_t) (((double) _ThreadState._SampleRate * _ThreadState._FFTDuration) / 1000.) : 64;
            break;
    }
    #pragma warning (default: 4061)

    if (_ThreadState._UseToneGenerator)
        _ToneGenerator.Initialize(997., 1., 0., _ThreadState._BinCount);
}

/// <summary>
/// Animates the values.
/// </summary>
void UIElement::Animate()
{
    // Needs to be called even when no audio is playing to keep animating the decay of the peak indicators after the audio stops.
    if (_MainState._PeakMode != PeakMode::None)
    {
        for (auto & Iter : _Grid)
            Iter._Graph->GetAnalysis().UpdatePeakValues(_ThreadState._PlaybackTime == 0.);
    }
}

#pragma region DirectX

/// <summary>
/// Creates resources which are not bound to any D3D device. Their lifetime effectively extends for the duration of the app.
/// </summary>
HRESULT UIElement::CreateDeviceIndependentResources()
{
    HRESULT hr = _FrameCounter.CreateDeviceIndependentResources();

    return hr;
}

/// <summary>
/// Releases the device independent resources.
/// </summary>
void UIElement::ReleaseDeviceIndependentResources()
{
    _FrameCounter.ReleaseDeviceIndependentResources();
}

/// <summary>
/// Creates resources which are bound to a particular D3D device.
/// It's all centralized here, in case the resources need to be recreated in case of D3D device loss (eg. display change, remoting, removal of video card, etc).
/// </summary>
HRESULT UIElement::CreateDeviceSpecificResources()
{
    CRect cr;

    GetClientRect(cr);

    const UINT32 Width  = (UINT32) (FLOAT) (cr.right  - cr.left);
    const UINT32 Height = (UINT32) (FLOAT) (cr.bottom - cr.top);

    HRESULT hr = (Width != 0) && (Height != 0) ? S_OK : DXGI_ERROR_INVALID_CALL;

    // Create the render target.
    if (SUCCEEDED(hr) && (_RenderTarget == nullptr))
    {
        D2D1_SIZE_U Size = D2D1::SizeU(Width, Height); // Set the size in pixels.

        D2D1_RENDER_TARGET_PROPERTIES RenderTargetProperties = D2D1::RenderTargetProperties
        (
            _MainState._UseHardwareRendering ? D2D1_RENDER_TARGET_TYPE_DEFAULT : D2D1_RENDER_TARGET_TYPE_SOFTWARE, D2D1::PixelFormat(DXGI_FORMAT_B8G8R8A8_UNORM, D2D1_ALPHA_MODE_PREMULTIPLIED)
        );
        D2D1_HWND_RENDER_TARGET_PROPERTIES WindowRenderTargetProperties = D2D1::HwndRenderTargetProperties(m_hWnd, Size);

        hr = _Direct2D.Factory->CreateHwndRenderTarget(RenderTargetProperties, WindowRenderTargetProperties, &_RenderTarget);

        if (SUCCEEDED(hr))
        {
            _RenderTarget->SetTransform(D2D1::Matrix3x2F::Identity());
            _RenderTarget->SetAntialiasMode(D2D1_ANTIALIAS_MODE_PER_PRIMITIVE);
            _RenderTarget->SetTextAntialiasMode(D2D1_TEXT_ANTIALIAS_MODE_GRAYSCALE); // https://learn.microsoft.com/en-us/windows/win32/direct2d/improving-direct2d-performance

            const D2D1_SIZE_F SizeF = _RenderTarget->GetSize(); // Gets the size in DPIs.

            _Grid.Resize(SizeF.width, SizeF.height);

            _ThreadState._StyleManager.ReleaseGradientBrushes();
        }
    }

    // Create the background bitmap from the artwork.
    if (SUCCEEDED(hr) && _Artwork.IsInitialized())
    {
    //  Log::Write(Log::Level::Trace, "%8d: Realizing artwork", (uint32_t) ::GetTickCount64());

        for (auto & Iter : _Grid)
            Iter._Graph->ReleaseDeviceSpecificResources();

        _Artwork.Realize(_RenderTarget);
    }

    // Create the resources that depend on the artwork. Done at least once per artwork because the configuration dialog needs it for the dominant color and ColorScheme::Artwork.
    if (SUCCEEDED(hr) && _Artwork.IsRealized())
        CreateArtworkDependentResources();

#ifdef _DEBUG
    if (SUCCEEDED(hr) && (_DebugBrush == nullptr))
        _RenderTarget->CreateSolidColorBrush(D2D1::ColorF(1.f,0.f,0.f), &_DebugBrush);
#endif

    return hr;
}

/// <summary>
/// Creates the DirectX resources that are dependent on the artwork.
/// </summary>
HRESULT UIElement::CreateArtworkDependentResources()
{
    // Get the colors from the artwork.
    HRESULT hr = _Artwork.GetColors(_ThreadState._ArtworkColors, _ThreadState._NumArtworkColors, _ThreadState._LightnessThreshold, _ThreadState._TransparencyThreshold);

    // Sort the colors.
    if (SUCCEEDED(hr))
    {
        _ThreadState._StyleManager._DominantColor = _ThreadState._ArtworkColors[0];

        #pragma warning(disable: 4061) // Enumerator not handled
        switch (_ThreadState._ColorOrder)
        {
            case ColorOrder::None:
                break;

            case ColorOrder::HueAscending:
                Color::SortColorsByHue(_ThreadState._ArtworkColors, true);
                break;

            case ColorOrder::HueDescending:
                Color::SortColorsByHue(_ThreadState._ArtworkColors, false);
                break;

            case ColorOrder::SaturationAscending:
                Color::SortColorsBySaturation(_ThreadState._ArtworkColors, true);
                break;

            case ColorOrder::SaturationDescending:
                Color::SortColorsBySaturation(_ThreadState._ArtworkColors, false);
                break;

            case ColorOrder::LightnessAscending:
                Color::SortColorsByLightness(_ThreadState._ArtworkColors, true);
                break;

            case ColorOrder::LightnessDescending:
                Color::SortColorsByLightness(_ThreadState._ArtworkColors, false);
                break;
        }
        #pragma warning(default: 4061)
    }

    // Create the gradient stops.
    if (SUCCEEDED(hr))
        hr = _Direct2D.CreateGradientStops(_ThreadState._ArtworkColors, _ThreadState._ArtworkGradientStops);

    if (SUCCEEDED(hr))
    {
        _ThreadState._StyleManager.SetArtworkDependentParameters(_ThreadState._ArtworkGradientStops, _ThreadState._StyleManager._DominantColor);
        _ThreadState._StyleManager.ReleaseGradientBrushes();

        _IsConfigurationChanged = true;
    }

    return S_OK; // Make sure resource creation continues even if something goes wrong while creating the gradient.
}

/// <summary>
/// Releases the device specific resources.
/// </summary>
void UIElement::ReleaseDeviceSpecificResources()
{
#ifdef _DEBUG
    _DebugBrush.Release();
#endif
    _ThreadState._StyleManager.ReleaseDeviceSpecificResources();

    for (auto & Iter : _Grid)
        Iter._Graph->ReleaseDeviceSpecificResources();

    _Artwork.Release();

    _FrameCounter.ReleaseDeviceSpecificResources();

    _RenderTarget.Release();
}

#pragma endregion
