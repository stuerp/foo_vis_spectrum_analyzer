
/** $VER: UIElementRendering.cpp (2025.10.21) P. Stuer - UIElement methods that run on the render thread. **/

#include "pch.h"
#include "UIElement.h"

#include "DirectX.h"
#include "Direct2D.h"
#include "DirectWrite.h"
#include "WIC.h"

#include "Resources.h"
#include "Color.h"
#include "Gradients.h"
#include "StyleManager.h"

#include "Log.h"

#pragma comment(lib, "d2d1")
#pragma comment(lib, "d3d11")
#pragma comment(lib, "dxgi")
#pragma comment(lib, "dxguid")
#pragma comment(lib, "dcomp.lib")

#pragma hdrstop

/// <summary>
/// Handles a timer tick.
/// </summary>
void uielement_t::OnTimer() noexcept
{
    if (_IsFrozen || !_IsVisible || ::IsIconic(m_hWnd)) // ::IsIconic(core_api::get_main_window()))
        return;

    LONG64 StateBarrier = ::InterlockedIncrement64(&_RenderThread._Barrier);

    if (StateBarrier != 1)
    {
        // The barrier is down. Prevent reentering.
        ::InterlockedDecrement64(&_RenderThread._Barrier);

        return;
    }

    bool HaveColorsChanged = false;

    if (_CriticalSection.TryEnter())
    {
        ProcessEvents();

        if (IsWindowVisible())
        {
            _FrameCounter.NewFrame();

            Process();

            Render();

            Animate();
        }

        if (_IsConfigurationChanged)
        {
            _UIThread._ArtworkGradientStops = _RenderThread._ArtworkGradientStops;

            _IsConfigurationChanged = false;

            HaveColorsChanged = true;
        }

        _CriticalSection.Leave();
    }

    // Notify the configuration dialog about the changed artwork colors.
    if (HaveColorsChanged && _ConfigurationDialog.IsWindow())
    {
        _ConfigurationDialog.PostMessageW(UM_CONFIGURATION_CHANGED, CC_COLORS); // Must be sent outside the critical section.

        Log.AtDebug().Write(STR_COMPONENT_BASENAME " notified configuration dialog of configuration change (Artwork colors).");

        HaveColorsChanged = false;
    }

    ::InterlockedDecrement64(&_RenderThread._Barrier);
}

/// <summary>
/// Allows the rendering thread to react to events captured in or generated by the UI thread.
/// </summary>
void uielement_t::ProcessEvents() noexcept
{
    const auto Flags = _Event.GetFlags();

    if (Flags == 0)
        return;

    if (event_t::IsRaised(Flags, event_t::PlaybackStopped))
    {
        _RenderThread._LastPlaybackTime = 0.;
        _RenderThread._TrackTime = 0.;

        for (auto & Iter : _Grid)
            Iter._Graph->Reset();
    }

    if (event_t::IsRaised(Flags, event_t::PlaybackStartedNewTrack))
    {
        _RenderThread._LastPlaybackTime = 0.;
        _RenderThread._TrackTime = 0.;

        for (auto & Iter : _Grid)
            Iter._Graph->Reset();

        if (_Artwork.Bitmap() == nullptr)
        {
            // Set the default dominant color and gradient for the artwork color scheme.
            _RenderThread._ArtworkGradientStops = GetBuiltInGradientStops(ColorScheme::Artwork);

            _RenderThread._StyleManager.DominantColor = _RenderThread._ArtworkGradientStops[0].color;
            _RenderThread._StyleManager.SetArtworkDependentParameters(_RenderThread._ArtworkGradientStops, _RenderThread._StyleManager.DominantColor);
            _RenderThread._StyleManager.DeleteGradientBrushes();

            _IsConfigurationChanged = true;
        }
    }

    if (event_t::IsRaised(Flags, event_t::UserInterfaceColorsChanged))
    {
        _RenderThread._StyleManager.UpdateCurrentColors();
        _RenderThread._StyleManager.DeleteDeviceSpecificResources();
    }
}

/// <summary>
/// Renders a frame.
/// </summary>
void uielement_t::Render() noexcept
{
    HRESULT hr = CreateDeviceSpecificResources();

    if (FAILED(hr))
        return;

    _DeviceContext->BeginDraw();

    _DeviceContext->Clear(D2D1::ColorF(0.f, 0.f, 0.f, 0.f)); // Required for alpha transparency. Do this once for all graphs. A graph can overlay a background color with a semi-transparent style.

    for (auto & Iter : _Grid)
        Iter._Graph->Render(_DeviceContext, _Artwork);

    if (_UIThread._ShowFrameCounter)
        _FrameCounter.Render(_DeviceContext);

    hr = _DeviceContext->EndDraw();

    // Present the swap chain immediately.
    if (SUCCEEDED(hr))
        hr = _SwapChain->Present(1, 0);

    if (hr == D2DERR_RECREATE_TARGET || hr == DXGI_ERROR_DEVICE_REMOVED)
    {
        DeleteDeviceSpecificResources();

        hr = S_OK;
    }
}

/// <summary>
/// Processes an audio chunk.
/// </summary>
void uielement_t::Process() noexcept
{
    if (!_VisualisationStream.is_valid())
        return;

    double PlaybackTime; // in seconds

    if (!(_VisualisationStream->get_absolute_time(PlaybackTime) && (PlaybackTime != _RenderThread._LastPlaybackTime)))
        return; // Playback is paused.

    double WindowSize   = 0.;
    double WIndowOffset = 0.;

    if (_RenderThread._SampleRate != 0)
    {
        const bool IsSlidingWindow = (_RenderThread._Transform == Transform::SWIFT) || (_RenderThread._Transform == Transform::AnalogStyle);

        WindowSize   = IsSlidingWindow ? PlaybackTime - _RenderThread._LastPlaybackTime : (double) _RenderThread._BinCount / (double) _RenderThread._SampleRate;
        WIndowOffset = IsSlidingWindow ?                _RenderThread._LastPlaybackTime : PlaybackTime - (WindowSize * (0.5 + _RenderThread._ReactionAlignment));
    }
    else
    {
        // Get a very small chunk from the visualisation stream to initialize the sample rate dependent parameters. Test with DSF files.
        WIndowOffset = PlaybackTime;
        WindowSize = 0.0005; // 500 Î¼s
    }

    audio_chunk_impl Chunk;

    if (_VisualisationStream->get_chunk_absolute(Chunk, WIndowOffset, WindowSize))
    {
        InitializeSampleRateDependentParameters(Chunk);

        for (auto & Iter : _Grid)
            Iter._Graph->Process(Chunk);
    }

    _RenderThread._LastPlaybackTime = PlaybackTime;
}

/// <summary>
/// Updates the peak values of all the graphs.
/// </summary>
void uielement_t::Animate() noexcept
{
    if (_UIThread._PeakMode == PeakMode::None)
        return;

    // Needs to be called even when no audio is playing to keep animating the decay of the peak indicators after the audio stops.
    for (auto & Iter : _Grid)
        Iter._Graph->_Analysis.UpdatePeakValues(_RenderThread._LastPlaybackTime == 0.);
}

/// <summary>
/// Initializes the parameters that depend on the sample rate of the chunk.
/// </summary>
void uielement_t::InitializeSampleRateDependentParameters(const audio_chunk_impl & chunk) noexcept
{
    if (_RenderThread._SampleRate == chunk.get_sample_rate())
        return;

    _RenderThread._SampleRate = chunk.get_sample_rate();

    Log.AtDebug().Write(STR_COMPONENT_BASENAME "chunk parameters: %d Hz, %d channels (0x%04X), %d frames, %.1fms", chunk.get_sample_rate(), chunk.get_channel_count(), chunk.get_channel_config(), chunk.get_sample_count(), chunk.get_duration() * 1000.);

    #pragma warning(disable: 4061)

    switch (_RenderThread._FFTMode)
    {
        default:
            _RenderThread._BinCount = (size_t) (64. * ::exp2((long) _RenderThread._FFTMode));
            break;

        case FFTMode::FFTCustom:
            _RenderThread._BinCount = (_RenderThread._FFTCustom > 0) ? (size_t) _RenderThread._FFTCustom : 64;
            break;

        case FFTMode::FFTDuration:
            _RenderThread._BinCount = (_RenderThread._FFTDuration > 0.) ? (size_t) (((double) _RenderThread._SampleRate * _RenderThread._FFTDuration) / 1000.) : 64;
            break;
    }

    #pragma warning(default: 4061)
}

/// <summary>
/// Handles a timer tick.
/// </summary>
void CALLBACK uielement_t::TimerCallback(PTP_CALLBACK_INSTANCE instance, PVOID context, PTP_TIMER timer) noexcept
{
    ((uielement_t *) context)->OnTimer();
}

#pragma region DirectX

/// <summary>
/// Creates resources which are not bound to any D3D device. Their lifetime effectively extends for the duration of the app.
/// </summary>
HRESULT uielement_t::CreateDeviceIndependentResources() noexcept
{
    DirectX::Initialize();

    HRESULT hr = S_OK;

    if (SUCCEEDED(hr))
        hr = ::CreateDXGIFactory(__uuidof(IDXGIFactory2), reinterpret_cast<void **>(&_DXGIFactory));

        UINT Flags = D3D11_CREATE_DEVICE_BGRA_SUPPORT;

#ifdef _DEBUG
        Flags |= D3D11_CREATE_DEVICE_DEBUG;
#endif

    if (SUCCEEDED(hr))
        hr = ::D3D11CreateDevice(nullptr, D3D_DRIVER_TYPE_HARDWARE, nullptr, Flags, nullptr, 0, D3D11_SDK_VERSION, &_D3DDevice, nullptr, &_D3DDeviceContext);

    if (SUCCEEDED(hr))
        hr = ::DCompositionCreateDevice(nullptr, __uuidof(IDCompositionDevice), reinterpret_cast<void **>(&_DCompositionDevice));

    hr = _FrameCounter.CreateDeviceIndependentResources();

    return hr;
}

/// <summary>
/// Releases the device independent resources.
/// </summary>
void uielement_t::DeleteDeviceIndependentResources() noexcept
{
    _FrameCounter.DeleteDeviceIndependentResources();

    _DCompositionDevice.Release();
    _D3DDeviceContext.Release();
    _D3DDevice.Release();
    _DXGIFactory.Release();

    DirectX::Terminate();
}

/// <summary>
/// Creates resources which are bound to a particular D3D device.
/// It's all centralized here, in case the resources need to be recreated in case of D3D device loss (eg. display change, remoting, removal of video card, etc).
/// </summary>
HRESULT uielement_t::CreateDeviceSpecificResources() noexcept
{
    HRESULT hr = S_OK;

    // Create the device context.
    if (_DeviceContext == nullptr)
    {
        CRect cr;

        GetClientRect(cr);

        const UINT32 Width  = (UINT) cr.Width();
        const UINT32 Height = (UINT) cr.Height();

        hr = (Width != 0) && (Height != 0) ? S_OK : DXGI_ERROR_INVALID_CALL;

        // Create the Direct2D device and the device context and get the monitor refresh from the DXGI device.
        {
            CComPtr<IDXGIDevice1> DXGIDevice;

            if (SUCCEEDED(hr))
                hr = _D3DDevice->QueryInterface(&DXGIDevice); // Get a DXGI device interface from the D3D device.

            if (SUCCEEDED(hr))
                hr = _Direct2D.Factory->CreateDevice(DXGIDevice, &_D2DDevice); // Create a D2D device from the DXGI device.

            if (SUCCEEDED(hr))
                hr = _D2DDevice->CreateDeviceContext(D2D1_DEVICE_CONTEXT_OPTIONS_ENABLE_MULTITHREADED_OPTIMIZATIONS, &_DeviceContext);

            if (SUCCEEDED(hr))
            {
                GetDPI(m_hWnd, _DPI);

                _DeviceContext->SetDpi((FLOAT) _DPI, (FLOAT) _DPI);
            }

            if (SUCCEEDED(hr))
                _Direct2D.GetRefreshRate(DXGIDevice, _DisplayRefreshRate); // Currently not used yet.
        }

        if (SUCCEEDED(hr))
        {
            DXGI_SWAP_CHAIN_DESC1 scd = { };

            scd.Width              = Width;
            scd.Height             = Height;
            scd.Format             = DXGI_FORMAT_B8G8R8A8_UNORM;
            scd.Scaling            = DXGI_SCALING_STRETCH;
            scd.SwapEffect         = DXGI_SWAP_EFFECT_FLIP_SEQUENTIAL;
            scd.BufferUsage        = DXGI_USAGE_RENDER_TARGET_OUTPUT;
            scd.BufferCount        = 2;
            scd.SampleDesc.Count   = 1;
            scd.SampleDesc.Quality = 0;
            scd.AlphaMode          = DXGI_ALPHA_MODE_PREMULTIPLIED; // Required for alpha transparency.
            scd.Flags              = 0;

            hr = _DXGIFactory->CreateSwapChainForComposition(_D3DDevice, &scd, nullptr, &_SwapChain);
        }

        // Set up DirectComposition.
        {
            if (SUCCEEDED(hr))
                hr = _DCompositionDevice->CreateTargetForHwnd(m_hWnd, TRUE, &_Target);

            if (SUCCEEDED(hr))
                hr = _DCompositionDevice->CreateVisual(&_Visual);

            if (SUCCEEDED(hr))
                hr = _Visual->SetContent(_SwapChain);

            if (SUCCEEDED(hr))
                hr = _Target->SetRoot(_Visual);

            if (SUCCEEDED(hr))
                hr = _DCompositionDevice->Commit();
        }

        if (SUCCEEDED(hr))
            hr = CreateBackBuffer();

        if (SUCCEEDED(hr))
            _DeviceContext->SetTarget(_BackBuffer);

        if (SUCCEEDED(hr))
        {
            _DeviceContext->SetTransform(D2D1::Matrix3x2F::Identity());
            _DeviceContext->SetAntialiasMode(D2D1_ANTIALIAS_MODE_PER_PRIMITIVE);
            _DeviceContext->SetTextAntialiasMode(D2D1_TEXT_ANTIALIAS_MODE_GRAYSCALE); // https://learn.microsoft.com/en-us/windows/win32/direct2d/improving-direct2d-performance

            const D2D1_SIZE_F SizeF = _DeviceContext->GetSize(); // Gets the size in DPIs.

            _Grid.Resize(SizeF.width, SizeF.height);
            _FrameCounter.Resize(SizeF.width, SizeF.height);

            _RenderThread._StyleManager.DeleteGradientBrushes();
        }

    #ifdef _DEBUG
        if (SUCCEEDED(hr) && (_DebugBrush == nullptr))
            _DeviceContext->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Red), &_DebugBrush);
    #endif
    }

    // Create the background bitmap from the artwork.
    if (SUCCEEDED(hr) && (_Artwork.Bitmap() == nullptr))
    {
        hr = _Artwork.CreateDeviceSpecificResources(_DeviceContext);

        if (SUCCEEDED(hr))
        {
            for (auto & Iter : _Grid)
                Iter._Graph->Release();
        }
        else
            hr = S_OK; // No WIC bitmap created because there is no artwork.
    }

    // Create the resources that depend on the artwork. Done at least once per artwork because the configuration dialog needs it for the dominant color and ColorScheme::Artwork.
    if (SUCCEEDED(hr) && _Artwork.IsRealized())
        CreateArtworkDependentResources();

    return hr;
}

/// <summary>
/// Releases the device specific resources.
/// </summary>
void uielement_t::DeleteDeviceSpecificResources() noexcept
{
#ifdef _DEBUG
    _DebugBrush.Release();
#endif

    _RenderThread._StyleManager.DeleteDeviceSpecificResources();

    for (auto & Iter : _Grid)
        Iter._Graph->Release();

    _Artwork.DeleteDeviceSpecificResources();

    _FrameCounter.DeleteDeviceSpecificResources();

    _BackBuffer.Release();
    _Visual.Release();
    _Target.Release();

    _SwapChain.Release();
    _DeviceContext.Release();
    _D2DDevice.Release();
}

/// <summary>
/// Creates the bitmap that will be the target of the device context.
/// </summary>
HRESULT uielement_t::CreateBackBuffer() noexcept
{
    CComPtr<IDXGISurface> Surface;

    // Get a surface from the swap chain.
    HRESULT hr = _SwapChain->GetBuffer(0, IID_PPV_ARGS(&Surface));

    if (FAILED(hr))
        return hr;

    // Create a bitmap pointing to the surface.
    D2D1_BITMAP_PROPERTIES1 Properties = D2D1::BitmapProperties1
    (
        D2D1_BITMAP_OPTIONS_TARGET | D2D1_BITMAP_OPTIONS_CANNOT_DRAW,
        D2D1::PixelFormat(DXGI_FORMAT_B8G8R8A8_UNORM, D2D1_ALPHA_MODE_PREMULTIPLIED), // Required for alpha transparency.
        (FLOAT) _DPI, (FLOAT) _DPI
    );

    hr = _DeviceContext->CreateBitmapFromDxgiSurface(Surface, &Properties, &_BackBuffer);

    if (FAILED(hr))
        return hr;

    Surface.Release();

    // Update the DirectComposition visual.
    if (_Visual && _Target)
    {
        hr = _Visual->SetContent(_SwapChain);

        if (FAILED(hr))
            return hr;

        hr = _Target->SetRoot(_Visual);

        if (FAILED(hr))
            return hr;

        hr = _DCompositionDevice->Commit();
    }

    return hr;
}

/// <summary>
/// Creates the DirectX resources that are dependent on the artwork.
/// </summary>
HRESULT uielement_t::CreateArtworkDependentResources() noexcept
{
    // Get the colors from the artwork.
    HRESULT hr = _Artwork.GetColors(_RenderThread._ArtworkColors, _RenderThread._NumArtworkColors, _RenderThread._LightnessThreshold, _RenderThread._TransparencyThreshold);

    // Sort the colors.
    if (SUCCEEDED(hr))
    {
        _RenderThread._StyleManager.DominantColor = _RenderThread._ArtworkColors[0];

        #pragma warning(disable: 4061) // Enumerator not handled
        switch (_RenderThread._ColorOrder)
        {
            case ColorOrder::None:
                break;

            case ColorOrder::HueAscending:
                color_t::SortColorsByHue(_RenderThread._ArtworkColors, true);
                break;

            case ColorOrder::HueDescending:
                color_t::SortColorsByHue(_RenderThread._ArtworkColors, false);
                break;

            case ColorOrder::SaturationAscending:
                color_t::SortColorsBySaturation(_RenderThread._ArtworkColors, true);
                break;

            case ColorOrder::SaturationDescending:
                color_t::SortColorsBySaturation(_RenderThread._ArtworkColors, false);
                break;

            case ColorOrder::LightnessAscending:
                color_t::SortColorsByLightness(_RenderThread._ArtworkColors, true);
                break;

            case ColorOrder::LightnessDescending:
                color_t::SortColorsByLightness(_RenderThread._ArtworkColors, false);
                break;
        }
        #pragma warning(default: 4061)
    }

    // Create the gradient stops.
    if (SUCCEEDED(hr))
        hr = _Direct2D.CreateGradientStops(_RenderThread._ArtworkColors, _RenderThread._ArtworkGradientStops);

    if (SUCCEEDED(hr))
    {
        _RenderThread._StyleManager.DominantColor = _RenderThread._ArtworkGradientStops[0].color;
        _RenderThread._StyleManager.SetArtworkDependentParameters(_RenderThread._ArtworkGradientStops, _RenderThread._StyleManager.DominantColor);
        _RenderThread._StyleManager.DeleteGradientBrushes();

        _IsConfigurationChanged = true;
    }

    return S_OK; // Make sure resource creation continues even if something goes wrong while creating the gradient.
}

#pragma endregion
